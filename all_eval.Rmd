---
output: 
  html_document:
    code_folding: hide
self_contained: yes
runtime: shiny
---

# Bayesian network tool

```{r globals, echo = T, message = F, warning = F}
knitr::opts_chunk$set(message = F, warning = F)

library(tidyverse)
library(ggmap)
library(lubridate)
library(geosphere)
library(stringi)
library(tibble)
library(bnlearn)
library(scales)
library(shiny)
library(sf)
library(sp)
library(gridExtra)

data(restdat)
data(reststat)
data(wqdat)
data(wqstat)

# source R files
source('R/get_chg.R')
source('R/get_clo.R')
source('R/get_dat.R')
source('R/get_lik.R')

# base map
ext <- make_bbox(wqstat$lon, wqstat$lat, f = 0.2)
map <- get_stamenmap(ext, zoom = 11, maptype = "toner-lite")
pbase <- ggmap(map) +
  theme_bw() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )
```

```{r}
## sliders

column(width = 12, 
  
  column(width = 6, 
    
    # which model to select
    selectInput("resgrp", label = 'Select model type:', 
                choices = list(
                  simple = 'top', 
                  complex = 'type'
                ), selected = 'simple'
              ),

    # wq year slice window
    numericInput("yrdf", "Choose year diff:", 5), 
    
    # wq site match upper limit
    numericInput("mtch", "Choose number of restoration matches:", 2),
    
    # dynamic UI for chl thresh
    renderUI({
      
      # ui rng inputs
      uirngs <- uirngs()
      
      # filter for chl
      chlrng <- uirngs %>% 
        filter(var == 'chla')

      # chl selector
      numericInput("chlspl", label = 'Select chl lo/hi split:',
        min = chlrng$minv, max = chlrng$maxv,
        value = chlrng$medv
        )

      }), 
    
    # dynamic UI for nit thresh
    renderUI({
      
      # ui rng inputs
      uirngs <- uirngs()
      
      # filter for nit
      nitrng <- uirngs %>% 
        filter(var == 'tn')

      # sal selector
      numericInput("nitspl", label = 'Select nitrogen lo/hi split:',
        min = nitrng$minv, max = nitrng$maxv,
        value = nitrng$medv
        )
    
      }), 
    
    # dynamic UI for sal thresh
    renderUI({
      
      # ui rng inputs
      uirngs <- uirngs()
      
      # filter for sal
      salrng <- uirngs %>% 
        filter(var == 'sal')
      
      # sal selector
      numericInput("salspl", label = 'Select sal lo/hi split:',
        min = salrng$minv, max = salrng$maxv,
        value = salrng$medv
        )
    
      })
    
  ),
  
  column(width = 6, 
         
    # year slider
    sliderInput("yrs", label = 'Select year ranges:',  
          min = 1974, max = 2016, 
          value = c(1974, 2016),
          sep = '', ticks = FALSE
        ), 
    
    renderPlot({plot(net())}, width = 450, height = 400)

  )
  
)
```

```{r}
## reactives

# bn class reactive
net <- reactive({
  
  # get net structure from model type
  resgrp <- input$resgrp
  if(resgrp == 'top')
    resgrp <- "[hab][wtr][salev|hab:wtr][chlev|hab:wtr:salev]"
  else 
    resgrp <- "[hab_enh][hab_est][hab_pro][non_src][pnt_src][salev|hab_enh:hab_est:hab_pro:non_src:pnt_src][nilev|salev:hab_enh:hab_est:hab_pro:non_src:pnt_src][chlev|nilev]"
                                     
  # create bn network object
  out <- model2network(resgrp)

  return(out)
  
})

# chl and sal ranges from year inputs, for dynamic ui selector of thresholds
uirngs <- reactive({
  
  # input years
  yrs <- input$yrs
   
  # get chl, sal ranges from year inputs   
  rngs <- wqdat %>% 
    mutate(yr = year(datetime)) %>% 
    filter(yr >= yrs[1] & yr <= yrs[2]) %>% 
    select(chla, sal, tn) %>% 
    gather('var', 'val') %>% 
    group_by(var) %>% 
    summarize(
      minv = min(val, na.rm = T), 
      medv = round(quantile(val, 0.5, na.rm = T), 2),
      maxv = max(val, na.rm = T)
    )
  
  return(rngs)
  
})

# reactives for restoration data subsets, data
restdat_sub <- reactive({
  
  out <- restdat %>% 
    filter(date >= input$yrs[1] & date <= input$yrs[2])
  
  return(out)
  
})

# reactives for restoration data subsets, station lat/lon
reststat_sub <- reactive({
  
  out <- reststat %>% 
    filter(id %in% restdat_sub()$id)
  
  return(out)
  
})

# wq stats matched to rest stats
allcdat <- reactive({
  
  # reactive inputs
  mtch <- input$mtch
  yrdf <- input$yrdf
  resgrp <- input$resgrp
  chlspl <- input$chlspl
  nitspl <- input$nitspl
  salspl <- input$salspl
  restdat_sub <- restdat_sub()
  reststat_sub <- reststat_sub()
  
  # get cdat and wqmtch
  out <- get_dat(resgrp, restdat, reststat, wqstat, wqdat, mtch, yrdf, chlspl, nitspl, salspl)
  
  return(out)
  
})

# get conditional data for bn input
cdat <- reactive({

  allcdat()$cdat

})

# get wqmtch for map
wqmtch <- reactive({

  allcdat()$wqmtch

})

# fit simple bn model
cdat_mod <- reactive({

  # inputs
  cdat <- cdat()

  # format cdat for model input
  cdat_frm <- cdat %>%
    select_if(is.factor) %>%
    na.omit %>%
    data.frame

  # fitted mod
  out <- bn.fit(net(), data = cdat_frm)

  return(out)

})

# get likelihood estimates from mod, bef/aft only (no salinity)
ests <- reactive({

  # inputs
  cdat <- cdat() # conditional data for mod input
  cdat_mod <- cdat_mod() # bn model

  # get likelihood
  out <- get_lik(cdat, cdat_mod)

  return(out)
  
})
```

# {.tabset}

## Spatial matches

```{r}

renderPlot({

  # reactives
  resgrp <- input$resgrp
  wqmtch <- wqmtch()
  restdat_sub <- restdat_sub()
  reststat_sub <- reststat_sub()
  
  # combine lat/lon for the plot
  toplo <- wqmtch %>%
    left_join(wqstat, by = 'stat') %>%
    left_join(reststat_sub, by = 'id') %>%
    rename(
      `Restoration type` = resgrp,
      `Distance (dd)` = dist
    )

  # restoration project grouping column
  restall <- left_join(restdat_sub, reststat_sub, by = 'id')
  names(restall)[names(restall) %in% resgrp] <- 'Restoration type'

  # outplot
  p <- pbase +
    geom_point(data = restall, aes(x = lon, y = lat, fill = `Restoration type`), size = 4, pch = 21) +
    geom_point(data = wqstat, aes(x = lon, y = lat), size = 2) +
    geom_segment(data = toplo, aes(x = lon.x, y = lat.x, xend = lon.y, yend = lat.y, alpha = -`Distance (dd)`, linetype = `Restoration type`), size = 1) +
    scale_alpha(guide = F) +
    theme_bw(base_family = 'serif', base_size = 16)

  return(p)

}, width = 550, height = 650)

```

## Chl response

```{r}
renderPlot({

  #inputs
  ests <- ests()

  # format for plot
  toplo <- ests %>%
    mutate(event = gsub('^wtr\\_|^hab\\_|^hab\\_enh\\_|^hab\\_est\\_|^hab\\_pro\\_|^non\\_src\\_|^pnt\\_src\\_', '', event)) %>%
    mutate(chlev = factor(chlev, levels = c('lo', 'hi'))) %>%
    spread(event, est) %>%
    mutate(
      chg = 100 * (aft - bef),
      chg = round(chg, 1)
      )
  
  # barplots of % change bef/aft
  p <- ggplot(toplo, aes(x = chlev, y = chg, group = project)) +
    geom_bar(colour = 'black', stat = 'identity', aes(fill = chg)) +
    theme_bw(base_family = 'serif', base_size = 16) +
    theme(
      strip.background = element_blank(),
      panel.grid = element_blank(),
      legend.position = 'none'
    ) +
    geom_hline(yintercept = 0) +
    xlab('Chlorophyll') +
    ylab('% change') +
    scale_fill_gradient2('% change', low = 'lightgreen', mid = "white", high = 'lightblue', midpoint = 0) +
    facet_wrap(~ project, ncol = 1)

  return(p)
  
}, width = 450, height = 600)

```


